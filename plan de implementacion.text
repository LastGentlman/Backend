El usuario ha respondido todas mis preguntas t√©cnicas:
1. 30 d√≠as de datos offline con alerta recordatorio
2. Last-write-wins para conflictos
3. Notificaciones push solo para el due√±o
4. 1 sucursal para el MVP

Ahora debo crear un plan de implementaci√≥n concreto y pr√°ctico con c√≥digo inicial para que pueda empezar hoy mismo. Voy a incluir:
- Estructura de proyecto
- C√≥digo base para empezar
- Schema de base de datos
- L√≥gica de sincronizaci√≥n offline
- Componentes clave

Me enfocar√© en las mejores pr√°cticas y en hacer algo que realmente funcione bien offline-first.

## üöÄ ¬°Perfecto! Aqu√≠ est√° tu plan de implementaci√≥n para **PedidoList**

### **Estructura del Proyecto**

```bash
pedidolist/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ web/                 # React PWA
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/  # Componentes UI
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/       # Hooks custom (useOffline, useSync)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/         # Utilidades
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stores/      # Zustand stores
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ workers/     # Service Worker
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ public/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ manifest.json
‚îÇ   ‚îî‚îÄ‚îÄ api/                 # Deno + Hono
‚îÇ       ‚îú‚îÄ‚îÄ routes/
‚îÇ       ‚îú‚îÄ‚îÄ middleware/
‚îÇ       ‚îî‚îÄ‚îÄ main.ts
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ database/            # Schema compartido
‚îÇ   ‚îî‚îÄ‚îÄ types/               # TypeScript types
‚îî‚îÄ‚îÄ supabase/
    ‚îî‚îÄ‚îÄ migrations/          # SQL migrations
```

### **1. Schema de Base de Datos (Supabase)**

-- Usuarios (aprovechamos Supabase Auth)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email VARCHAR(255) NOT NULL,
  name VARCHAR(255),
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Negocios (preparado para multi-brand futuro)
CREATE TABLE businesses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id UUID NOT NULL REFERENCES profiles(id),
  name VARCHAR(255) NOT NULL,
  subdomain VARCHAR(50) UNIQUE,
  brand_id VARCHAR(50) DEFAULT 'generic',
  subscription_status VARCHAR(20) DEFAULT 'trial',
  trial_ends_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '7 days'),
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Empleados
CREATE TABLE employees (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id),
  role VARCHAR(20) NOT NULL CHECK (role IN ('owner', 'admin', 'seller')),
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(business_id, user_id)
);

-- Sucursales (por ahora solo 1)
CREATE TABLE branches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL DEFAULT 'Principal',
  address TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Productos/Servicios
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  price DECIMAL(10,2) NOT NULL,
  category VARCHAR(100),
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Pedidos
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  business_id UUID NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
  branch_id UUID NOT NULL REFERENCES branches(id),
  employee_id UUID NOT NULL REFERENCES employees(id),
  
  -- Datos del pedido
  client_name VARCHAR(255) NOT NULL,
  client_phone VARCHAR(20),
  total DECIMAL(10,2) NOT NULL,
  delivery_date DATE NOT NULL,
  delivery_time TIME,
  notes TEXT,
  
  -- Estado
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'preparing', 'ready', 'delivered', 'cancelled')),
  
  -- Sincronizaci√≥n offline
  client_generated_id VARCHAR(255) UNIQUE, -- ID generado en el cliente
  last_modified_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  modified_by UUID REFERENCES profiles(id),
  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Detalle de pedidos
CREATE TABLE order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  product_id UUID REFERENCES products(id),
  product_name VARCHAR(255) NOT NULL, -- Guardamos el nombre por si el producto se elimina
  quantity INTEGER NOT NULL DEFAULT 1,
  unit_price DECIMAL(10,2) NOT NULL,
  subtotal DECIMAL(10,2) NOT NULL,
  notes TEXT
);

-- √çndices para performance
CREATE INDEX idx_orders_business_date ON orders(business_id, delivery_date);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_client_generated_id ON orders(client_generated_id);

-- RLS (Row Level Security)
ALTER TABLE businesses ENABLE ROW LEVEL SECURITY;
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- Pol√≠ticas b√°sicas
CREATE POLICY "Users can view their businesses" ON businesses
  FOR   SELECT USING (
    owner_id = auth.uid() OR 
    EXISTS (
      SELECT 1 FROM employees 
      WHERE employees.business_id = businesses.id 
      AND employees.user_id = auth.uid()
    )
  );

CREATE POLICY "Employees can manage orders" ON orders
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM employees 
      WHERE employees.business_id = orders.business_id 
      AND employees.user_id = auth.uid()
      AND employees.is_active = true
    )
  );

-- Funci√≥n para limpiar datos antiguos (m√°s de 30 d√≠as)
CREATE OR REPLACE FUNCTION cleanup_old_offline_data()
RETURNS void AS $$
BEGIN
  -- Esta funci√≥n se ejecutar√° desde el backend
  -- para limpiar datos de m√°s de 30 d√≠as en dispositivos
  -- Por ahora solo es un placeholder
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar last_modified_at
CREATE OR REPLACE FUNCTION update_last_modified()
RETURNS TRIGGER AS $$
BEGIN
  NEW.last_modified_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_orders_last_modified
  BEFORE UPDATE ON orders
  FOR EACH ROW
  EXECUTE FUNCTION update_last_modified();

Ahora voy a crear el c√≥digo base para la sincronizaci√≥n offline y los componentes principales. Necesito incluir:
1. Service Worker para PWA
2. Hook de sincronizaci√≥n offline
3. Store de Zustand para manejo de estado
4. Componente de estado de conexi√≥n
5. L√≥gica de sincronizaci√≥n

### **2. Sistema de Sincronizaci√≥n Offline**

// lib/offline/db.ts
import Dexie, { Table } from 'dexie';
import { Order, Product, SyncQueueItem } from '@/types';

export class PedidoListDB extends Dexie {
  orders!: Table<Order>;
  products!: Table<Product>;
  syncQueue!: Table<SyncQueueItem>;

  constructor() {
    super('PedidoListDB');
    
    this.version(1).stores({
      orders: '++id, clientGeneratedId, businessId, status, deliveryDate, [businessId+deliveryDate], syncStatus',
      products: '++id, businessId, name',
      syncQueue: '++id, entityType, entityId, action, timestamp, retries'
    });
  }

  // Limpiar datos de m√°s de 30 d√≠as
  async cleanupOldData() {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    await this.orders
      .where('deliveryDate')
      .below(thirtyDaysAgo.toISOString())
      .delete();
  }

  // Verificar si quedan pocos d√≠as de datos
  async checkDataExpiration(): Promise<number> {
    const oldestOrder = await this.orders
      .orderBy('deliveryDate')
      .first();
    
    if (!oldestOrder) return 30;
    
    const daysRemaining = Math.floor(
      (new Date().getTime() - new Date(oldestOrder.deliveryDate).getTime()) / 
      (1000 * 60 * 60 * 24)
    );
    
    return Math.max(0, 30 - daysRemaining);
  }
}

export const db = new PedidoListDB();

// hooks/useOfflineSync.ts
import { useEffect, useCallback, useState } from 'react';
import { supabase } from '@/lib/supabase';
import { db } from '@/lib/offline/db';
import { useStore } from '@/stores/appStore';
import { toast } from 'sonner';

export function useOfflineSync() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [syncStatus, setSyncStatus] = useState<'idle' | 'syncing' | 'error'>('idle');
  const { user, businessId, isOwner } = useStore();

  // Detectar cambios de conexi√≥n
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      toast.success('Conexi√≥n restaurada. Sincronizando...');
      syncPendingChanges();
    };

    const handleOffline = () => {
      setIsOnline(false);
      toast.warning('Sin conexi√≥n. Los cambios se guardar√°n localmente.');
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Sincronizar cambios pendientes
  const syncPendingChanges = useCallback(async () => {
    if (!isOnline || syncStatus === 'syncing') return;

    setSyncStatus('syncing');
    
    try {
      // Obtener items pendientes de sincronizar
      const pendingItems = await db.syncQueue.toArray();
      
      for (const item of pendingItems) {
        try {
          switch (item.entityType) {
            case 'order':
              await syncOrder(item);
              break;
            case 'product':
              await syncProduct(item);
              break;
          }
          
          // Eliminar de la cola si se sincroniz√≥ correctamente
          await db.syncQueue.delete(item.id!);
        } catch (error) {
          // Incrementar reintentos
          await db.syncQueue.update(item.id!, {
            retries: (item.retries || 0) + 1,
            lastError: error.message
          });
        }
      }

      // Notificar al due√±o si hay pedidos nuevos
      if (isOwner && pendingItems.some(item => item.entityType === 'order')) {
        const newOrdersCount = pendingItems.filter(
          item => item.entityType === 'order' && item.action === 'create'
        ).length;
        
        if (newOrdersCount > 0) {
          await sendPushNotification(
            `Se sincronizaron ${newOrdersCount} pedidos nuevos`
          );
        }
      }

      setSyncStatus('idle');
      toast.success('Sincronizaci√≥n completada');
    } catch (error) {
      setSyncStatus('error');
      toast.error('Error al sincronizar. Se reintentar√° autom√°ticamente.');
    }
  }, [isOnline, syncStatus, isOwner]);

  // Sincronizar un pedido espec√≠fico
  const syncOrder = async (item: SyncQueueItem) => {
    const localOrder = await db.orders.get(item.entityId);
    if (!localOrder) return;

    const { data, error } = await supabase
      .from('orders')
      .upsert({
        ...localOrder,
        client_generated_id: localOrder.clientGeneratedId,
        modified_by: user?.id
      })
      .select()
      .single();

    if (error) throw error;

    // Actualizar el ID local con el ID del servidor
    if (data && localOrder.id !== data.id) {
      await db.orders.update(localOrder.id!, {
        id: data.id,
        syncStatus: 'synced'
      });
    }
  };

  // Verificar espacio de almacenamiento
  useEffect(() => {
    const checkStorage = async () => {
      const daysRemaining = await db.checkDataExpiration();
      
      if (daysRemaining <= 5) {
        toast.warning(
          `Atenci√≥n: Los pedidos offline de m√°s de 30 d√≠as se eliminar√°n en ${daysRemaining} d√≠as`,
          { duration: 10000 }
        );
      }
    };

    checkStorage();
    // Verificar cada d√≠a
    const interval = setInterval(checkStorage, 24 * 60 * 60 * 1000);
    return () => clearInterval(interval);
  }, []);

  return {
    isOnline,
    syncStatus,
    syncPendingChanges,
    pendingCount: db.syncQueue.count()
  };
}

// components/ConnectionStatus.tsx
import { useOfflineSync } from '@/hooks/useOfflineSync';
import { Wifi, WifiOff, RefreshCw } from 'lucide-react';
import { cn } from '@/lib/utils';

export function ConnectionStatus() {
  const { isOnline, syncStatus, pendingCount } = useOfflineSync();

  return (
    <div className={cn(
      "flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-medium",
      isOnline ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800"
    )}>
      {isOnline ? (
        <>
          <Wifi className="w-4 h-4" />
          {syncStatus === 'syncing' ? (
            <>
              <RefreshCw className="w-4 h-4 animate-spin" />
              Sincronizando...
            </>
          ) : (
            'En l√≠nea'
          )}
        </>
      ) : (
        <>
          <WifiOff className="w-4 h-4" />
          Sin conexi√≥n
          {pendingCount > 0 && (
            <span className="ml-1">({pendingCount} pendientes)</span>
          )}
        </>
      )}
    </div>
  );
}

// hooks/useOrders.ts - Hook principal para manejar pedidos
import { useMutation, useQuery } from '@tanstack/react-query';
import { v4 as uuidv4 } from 'uuid';

export function useOrders() {
  const { businessId, branchId, user } = useStore();
  const { isOnline } = useOfflineSync();

  // Crear pedido (offline-first)
  const createOrder = useMutation({
    mutationFn: async (orderData: CreateOrderInput) => {
      const clientGeneratedId = uuidv4();
      const order = {
        ...orderData,
        id: clientGeneratedId,
        clientGeneratedId,
        businessId,
        branchId,
        employeeId: user?.id,
        syncStatus: 'pending'
      };

      // Siempre guardar primero en local
      await db.orders.add(order);

      // Agregar a la cola de sincronizaci√≥n
      await db.syncQueue.add({
        entityType: 'order',
        entityId: clientGeneratedId,
        action: 'create',
        timestamp: new Date().toISOString(),
        retries: 0
      });

      // Si hay conexi√≥n, intentar sincronizar inmediatamente
      if (isOnline) {
        try {
          const { data } = await supabase
            .from('orders')
            .insert(order)
            .select()
            .single();

          if (data) {
            await db.orders.update(clientGeneratedId, {
              id: data.id,
              syncStatus: 'synced'
            });
            await db.syncQueue.where('entityId').equals(clientGeneratedId).delete();
          }
        } catch (error) {
          console.error('Error sincronizando, se guard√≥ localmente:', error);
        }
      }

      return order;
    },
    onSuccess: () => {
      toast.success('Pedido creado exitosamente');
    }
  });

  // Obtener pedidos del d√≠a (offline-first)
  const todayOrders = useQuery({
    queryKey: ['orders', 'today', businessId],
    queryFn: async () => {
      const today = new Date().toISOString().split('T')[0];
      
      // Primero intentar obtener de local
      const localOrders = await db.orders
        .where(['businessId', 'deliveryDate'])
        .equals([businessId, today])
        .toArray();

      // Si hay conexi√≥n, sincronizar con el servidor
      if (isOnline) {
        try {
          const { data } = await supabase
            .from('orders')
            .select('*')
            .eq('business_id', businessId)
            .eq('delivery_date', today);

          if (data) {
            // Merge con datos locales (local tiene prioridad para no-sincronizados)
            const mergedOrders = mergeOrders(localOrders, data);
            return mergedOrders;
          }
        } catch (error) {
          console.error('Error obteniendo del servidor, usando datos locales:', error);
        }
      }

      return localOrders;
    },
    refetchInterval: isOnline ? 30000 : false // Refrescar cada 30s si hay conexi√≥n
  });

  return {
    createOrder,
    todayOrders,
    // ... m√°s m√©todos
  };
}

Ahora voy a crear el Service Worker para la PWA y el componente principal para crear pedidos con la funcionalidad de mini-recibo para WhatsApp.

### **3. PWA Service Worker y Componente de Pedidos**

// public/sw.js - Service Worker
const CACHE_NAME = 'pedidolist-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js',
  '/manifest.json',
  '/offline.html'
];

// Instalar SW
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// Estrategia de cache: Network First, fallback to cache
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Clonar la respuesta
        const responseToCache = response.clone();
        
        caches.open(CACHE_NAME)
          .then(cache => {
            cache.put(event.request, responseToCache);
          });
        
        return response;
      })
      .catch(() => {
        return caches.match(event.request)
          .then(response => {
            if (response) {
              return response;
            }
            // Si es una navegaci√≥n, mostrar p√°gina offline
            if (event.request.mode === 'navigate') {
              return caches.match('/offline.html');
            }
          });
      })
  );
});

// components/CreateOrder.tsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Calendar, Clock, Copy, MessageCircle, Plus, X } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { toast } from 'sonner';
import { useOrders } from '@/hooks/useOrders';
import { formatCurrency } from '@/lib/utils';

const orderSchema = z.object({
  clientName: z.string().min(1, 'Nombre del cliente requerido'),
  clientPhone: z.string().optional(),
  deliveryDate: z.string().min(1, 'Fecha de entrega requerida'),
  deliveryTime: z.string().optional(),
  notes: z.string().optional(),
  items: z.array(z.object({
    productName: z.string().min(1, 'Nombre del producto requerido'),
    quantity: z.number().min(1, 'Cantidad m√≠nima: 1'),
    unitPrice: z.number().min(0, 'Precio debe ser mayor a 0')
  })).min(1, 'Agrega al menos un producto')
});

type OrderFormData = z.infer<typeof orderSchema>;

export function CreateOrder() {
  const { createOrder } = useOrders();
  const [isCreating, setIsCreating] = useState(false);
  const [lastReceipt, setLastReceipt] = useState<string>('');

  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch,
    reset
  } = useForm<OrderFormData>({
    resolver: zodResolver(orderSchema),
    defaultValues: {
      items: [{ productName: '', quantity: 1, unitPrice: 0 }],
      deliveryDate: new Date().toISOString().split('T')[0]
    }
  });

  const items = watch('items');
  const total = items.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);

  const addItem = () => {
    setValue('items', [...items, { productName: '', quantity: 1, unitPrice: 0 }]);
  };

  const removeItem = (index: number) => {
    if (items.length > 1) {
      setValue('items', items.filter((_, i) => i !== index));
    }
  };

  const generateReceipt = (data: OrderFormData) => {
    const itemsList = data.items
      .map(item => `‚Ä¢ ${item.quantity}x ${item.productName} - ${formatCurrency(item.quantity * item.unitPrice)}`)
      .join('\n');

    const receipt = `üßæ *PEDIDO CONFIRMADO*
    
Cliente: ${data.clientName}
${data.clientPhone ? `Tel√©fono: ${data.clientPhone}` : ''}

üìÖ Entrega: ${new Date(data.deliveryDate).toLocaleDateString('es-MX', {
  weekday: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric'
})}${data.deliveryTime ? ` a las ${data.deliveryTime}` : ''}

üì¶ *Productos:*
${itemsList}

üí∞ *TOTAL: ${formatCurrency(total)}*

${data.notes ? `\nüìù Notas: ${data.notes}` : ''}

‚úÖ Gracias por su preferencia
_${new Date().toLocaleString('es-MX')}_`;

    return receipt;
  };

  const onSubmit = async (data: OrderFormData